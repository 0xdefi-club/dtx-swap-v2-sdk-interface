'use strict'
function t(t) {
  return t && 'object' == typeof t && 'default' in t ? t.default : t
}
Object.defineProperty(exports, '__esModule', { value: !0 })
var e,
  n = t(require('jsbi')),
  r = require('@uniswap/sdk-core'),
  o = t(require('tiny-invariant')),
  u = require('@ethersproject/solidity'),
  i = require('@ethersproject/address'),
  s =
    (((e = {})[84532] = '0x61b781d983f5D2134946dF130E9B62962C71b2C0'),
    (e[167e3] = '0x2EA9051d5a48eA2350b26306f2b959D262cf67e1'),
    '0x8615843ab28b4b86b2382dca22cf14f0a6ba9e52cb006531eb574042a5b54a46'),
  a = n.BigInt(1e3),
  c = n.BigInt(0),
  p = n.BigInt(1),
  l = n.BigInt(5),
  f = n.BigInt(997),
  m = n.BigInt(1e3)
function h(t, e) {
  for (var n = 0; n < e.length; n++) {
    var r = e[n]
    ;(r.enumerable = r.enumerable || !1),
      (r.configurable = !0),
      'value' in r && (r.writable = !0),
      Object.defineProperty(t, r.key, r)
  }
}
function d(t, e, n) {
  return e && h(t.prototype, e), n && h(t, n), t
}
function y(t, e) {
  ;(t.prototype = Object.create(e.prototype)), (t.prototype.constructor = t), (t.__proto__ = e)
}
function v(t) {
  return (v = Object.setPrototypeOf
    ? Object.getPrototypeOf
    : function(t) {
        return t.__proto__ || Object.getPrototypeOf(t)
      })(t)
}
function A(t, e) {
  return (A =
    Object.setPrototypeOf ||
    function(t, e) {
      return (t.__proto__ = e), t
    })(t, e)
}
function T() {
  if ('undefined' == typeof Reflect || !Reflect.construct) return !1
  if (Reflect.construct.sham) return !1
  if ('function' == typeof Proxy) return !0
  try {
    return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), !0
  } catch (t) {
    return !1
  }
}
function q(t, e, n) {
  return (q = T()
    ? Reflect.construct
    : function(t, e, n) {
        var r = [null]
        r.push.apply(r, e)
        var o = new (Function.bind.apply(t, r))()
        return n && A(o, n.prototype), o
      }).apply(null, arguments)
}
function k(t) {
  var e = 'function' == typeof Map ? new Map() : void 0
  return (k = function(t) {
    if (null === t || -1 === Function.toString.call(t).indexOf('[native code]')) return t
    if ('function' != typeof t) throw new TypeError('Super expression must either be null or a function')
    if (void 0 !== e) {
      if (e.has(t)) return e.get(t)
      e.set(t, n)
    }
    function n() {
      return q(t, arguments, v(this).constructor)
    }
    return (
      (n.prototype = Object.create(t.prototype, {
        constructor: { value: n, enumerable: !1, writable: !0, configurable: !0 }
      })),
      A(n, t)
    )
  })(t)
}
function g(t) {
  if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
  return t
}
function w(t, e) {
  ;(null == e || e > t.length) && (e = t.length)
  for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n]
  return r
}
function b(t, e) {
  var n
  if ('undefined' == typeof Symbol || null == t[Symbol.iterator]) {
    if (
      Array.isArray(t) ||
      (n = (function(t, e) {
        if (t) {
          if ('string' == typeof t) return w(t, void 0)
          var n = Object.prototype.toString.call(t).slice(8, -1)
          return (
            'Object' === n && t.constructor && (n = t.constructor.name),
            'Map' === n || 'Set' === n
              ? Array.from(t)
              : 'Arguments' === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
              ? w(t, void 0)
              : void 0
          )
        }
      })(t)) ||
      (e && t && 'number' == typeof t.length)
    ) {
      n && (t = n)
      var r = 0
      return function() {
        return r >= t.length ? { done: !0 } : { done: !1, value: t[r++] }
      }
    }
    throw new TypeError(
      'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
    )
  }
  return (n = t[Symbol.iterator]()).next.bind(n)
}
var x = 'setPrototypeOf' in Object,
  I = (function(t) {
    function e() {
      var n
      return (
        ((n = t.call(this) || this).isInsufficientReservesError = !0),
        (n.name = n.constructor.name),
        x && Object.setPrototypeOf(g(n), (this instanceof e ? this.constructor : void 0).prototype),
        n
      )
    }
    return y(e, t), e
  })(k(Error)),
  O = (function(t) {
    function e() {
      var n
      return (
        ((n = t.call(this) || this).isInsufficientInputAmountError = !0),
        (n.name = n.constructor.name),
        x && Object.setPrototypeOf(g(n), (this instanceof e ? this.constructor : void 0).prototype),
        n
      )
    }
    return y(e, t), e
  })(k(Error)),
  E = function(t) {
    var e = t.factoryAddress,
      n = t.tokenA,
      r = t.tokenB,
      o = n.sortsBefore(r) ? [n, r] : [r, n]
    return i.getCreate2Address(
      e,
      u.keccak256(['bytes'], [u.pack(['address', 'address'], [o[0].address, o[1].address])]),
      s
    )
  },
  P = (function() {
    function t(e, n) {
      var o = e.currency.sortsBefore(n.currency) ? [e, n] : [n, e]
      ;(this.liquidityToken = new r.Token(
        o[0].currency.chainId,
        t.getAddress(o[0].currency, o[1].currency),
        18,
        'UNI-V2',
        'Uniswap V2'
      )),
        (this.tokenAmounts = o)
    }
    t.getAddress = function(t, e) {
      return E({ factoryAddress: '0x2EA9051d5a48eA2350b26306f2b959D262cf67e1', tokenA: t, tokenB: e })
    }
    var e = t.prototype
    return (
      (e.involvesToken = function(t) {
        return t.equals(this.token0) || t.equals(this.token1)
      }),
      (e.priceOf = function(t) {
        return this.involvesToken(t) || o(!1), t.equals(this.token0) ? this.token0Price : this.token1Price
      }),
      (e.reserveOf = function(t) {
        return this.involvesToken(t) || o(!1), t.equals(this.token0) ? this.reserve0 : this.reserve1
      }),
      (e.getOutputAmount = function(e) {
        if (
          (this.involvesToken(e.currency) || o(!1),
          n.equal(this.reserve0.quotient, c) || n.equal(this.reserve1.quotient, c))
        )
          throw new I()
        var u = this.reserveOf(e.currency),
          i = this.reserveOf(e.currency.equals(this.token0) ? this.token1 : this.token0),
          s = n.multiply(e.quotient, f),
          a = n.multiply(s, i.quotient),
          p = n.add(n.multiply(u.quotient, m), s),
          l = r.CurrencyAmount.fromRawAmount(e.currency.equals(this.token0) ? this.token1 : this.token0, n.divide(a, p))
        if (n.equal(l.quotient, c)) throw new O()
        return [l, new t(u.add(e), i.subtract(l))]
      }),
      (e.getInputAmount = function(e) {
        if (
          (this.involvesToken(e.currency) || o(!1),
          n.equal(this.reserve0.quotient, c) ||
            n.equal(this.reserve1.quotient, c) ||
            n.greaterThanOrEqual(e.quotient, this.reserveOf(e.currency).quotient))
        )
          throw new I()
        var u = this.reserveOf(e.currency),
          i = this.reserveOf(e.currency.equals(this.token0) ? this.token1 : this.token0),
          s = n.multiply(n.multiply(i.quotient, e.quotient), m),
          a = n.multiply(n.subtract(u.quotient, e.quotient), f),
          l = r.CurrencyAmount.fromRawAmount(
            e.currency.equals(this.token0) ? this.token1 : this.token0,
            n.add(n.divide(s, a), p)
          )
        return [l, new t(i.add(l), u.subtract(e))]
      }),
      (e.getLiquidityMinted = function(t, e, u) {
        t.currency.equals(this.liquidityToken) || o(!1)
        var i,
          s = e.currency.sortsBefore(u.currency) ? [e, u] : [u, e]
        if (((s[0].currency.equals(this.token0) && s[1].currency.equals(this.token1)) || o(!1), n.equal(t.quotient, c)))
          i = n.subtract(r.sqrt(n.multiply(s[0].quotient, s[1].quotient)), a)
        else {
          var p = n.divide(n.multiply(s[0].quotient, t.quotient), this.reserve0.quotient),
            l = n.divide(n.multiply(s[1].quotient, t.quotient), this.reserve1.quotient)
          i = n.lessThanOrEqual(p, l) ? p : l
        }
        if (!n.greaterThan(i, c)) throw new O()
        return r.CurrencyAmount.fromRawAmount(this.liquidityToken, i)
      }),
      (e.getLiquidityValue = function(t, e, u, i, s) {
        var a
        if (
          (void 0 === i && (i = !1),
          this.involvesToken(t) || o(!1),
          e.currency.equals(this.liquidityToken) || o(!1),
          u.currency.equals(this.liquidityToken) || o(!1),
          n.lessThanOrEqual(u.quotient, e.quotient) || o(!1),
          i)
        ) {
          s || o(!1)
          var p = n.BigInt(s)
          if (n.equal(p, c)) a = e
          else {
            var f = r.sqrt(n.multiply(this.reserve0.quotient, this.reserve1.quotient)),
              m = r.sqrt(p)
            if (n.greaterThan(f, m)) {
              var h = n.multiply(e.quotient, n.subtract(f, m)),
                d = n.add(n.multiply(f, l), m),
                y = n.divide(h, d)
              a = e.add(r.CurrencyAmount.fromRawAmount(this.liquidityToken, y))
            } else a = e
          }
        } else a = e
        return r.CurrencyAmount.fromRawAmount(
          t,
          n.divide(n.multiply(u.quotient, this.reserveOf(t).quotient), a.quotient)
        )
      }),
      d(t, [
        {
          key: 'token0Price',
          get: function() {
            var t = this.tokenAmounts[1].divide(this.tokenAmounts[0])
            return new r.Price(this.token0, this.token1, t.denominator, t.numerator)
          }
        },
        {
          key: 'token1Price',
          get: function() {
            var t = this.tokenAmounts[0].divide(this.tokenAmounts[1])
            return new r.Price(this.token1, this.token0, t.denominator, t.numerator)
          }
        },
        {
          key: 'chainId',
          get: function() {
            return this.token0.chainId
          }
        },
        {
          key: 'token0',
          get: function() {
            return this.tokenAmounts[0].currency
          }
        },
        {
          key: 'token1',
          get: function() {
            return this.tokenAmounts[1].currency
          }
        },
        {
          key: 'reserve0',
          get: function() {
            return this.tokenAmounts[0]
          }
        },
        {
          key: 'reserve1',
          get: function() {
            return this.tokenAmounts[1]
          }
        }
      ]),
      t
    )
  })(),
  _ = (function() {
    function t(t, e, n) {
      ;(this._midPrice = null), t.length > 0 || o(!1)
      var r = t[0].chainId
      t.every(function(t) {
        return t.chainId === r
      }) || o(!1)
      var u = e.wrapped
      t[0].involvesToken(u) || o(!1), void 0 === n || t[t.length - 1].involvesToken(n.wrapped) || o(!1)
      for (var i, s = [u], a = b(t.entries()); !(i = a()).done; ) {
        var c = i.value,
          p = c[1],
          l = s[c[0]]
        l.equals(p.token0) || l.equals(p.token1) || o(!1)
        var f = l.equals(p.token0) ? p.token1 : p.token0
        s.push(f)
      }
      ;(this.pairs = t), (this.path = s), (this.input = e), (this.output = n)
    }
    return (
      d(t, [
        {
          key: 'midPrice',
          get: function() {
            if (null !== this._midPrice) return this._midPrice
            for (var t, e = [], n = b(this.pairs.entries()); !(t = n()).done; ) {
              var o = t.value,
                u = o[1]
              e.push(
                this.path[o[0]].equals(u.token0)
                  ? new r.Price(u.reserve0.currency, u.reserve1.currency, u.reserve0.quotient, u.reserve1.quotient)
                  : new r.Price(u.reserve1.currency, u.reserve0.currency, u.reserve1.quotient, u.reserve0.quotient)
              )
            }
            var i = e.slice(1).reduce(function(t, e) {
              return t.multiply(e)
            }, e[0])
            return (this._midPrice = new r.Price(this.input, this.output, i.denominator, i.numerator))
          }
        },
        {
          key: 'chainId',
          get: function() {
            return this.pairs[0].chainId
          }
        }
      ]),
      t
    )
  })()
function C(t, e) {
  return (
    t.inputAmount.currency.equals(e.inputAmount.currency) || o(!1),
    t.outputAmount.currency.equals(e.outputAmount.currency) || o(!1),
    t.outputAmount.equalTo(e.outputAmount)
      ? t.inputAmount.equalTo(e.inputAmount)
        ? 0
        : t.inputAmount.lessThan(e.inputAmount)
        ? -1
        : 1
      : t.outputAmount.lessThan(e.outputAmount)
      ? 1
      : -1
  )
}
function R(t, e) {
  var n = C(t, e)
  return 0 !== n
    ? n
    : t.priceImpact.lessThan(e.priceImpact)
    ? -1
    : t.priceImpact.greaterThan(e.priceImpact)
    ? 1
    : t.route.path.length - e.route.path.length
}
var F = (function() {
  function t(t, e, n) {
    ;(this.route = t), (this.tradeType = n)
    var u = new Array(t.path.length)
    if (n === r.TradeType.EXACT_INPUT) {
      e.currency.equals(t.input) || o(!1), (u[0] = e.wrapped)
      for (var i = 0; i < t.path.length - 1; i++) {
        var s = t.pairs[i].getOutputAmount(u[i])
        u[i + 1] = s[0]
      }
      ;(this.inputAmount = r.CurrencyAmount.fromFractionalAmount(t.input, e.numerator, e.denominator)),
        (this.outputAmount = r.CurrencyAmount.fromFractionalAmount(
          t.output,
          u[u.length - 1].numerator,
          u[u.length - 1].denominator
        ))
    } else {
      e.currency.equals(t.output) || o(!1), (u[u.length - 1] = e.wrapped)
      for (var a = t.path.length - 1; a > 0; a--) {
        var c = t.pairs[a - 1].getInputAmount(u[a])
        u[a - 1] = c[0]
      }
      ;(this.inputAmount = r.CurrencyAmount.fromFractionalAmount(t.input, u[0].numerator, u[0].denominator)),
        (this.outputAmount = r.CurrencyAmount.fromFractionalAmount(t.output, e.numerator, e.denominator))
    }
    ;(this.executionPrice = new r.Price(
      this.inputAmount.currency,
      this.outputAmount.currency,
      this.inputAmount.quotient,
      this.outputAmount.quotient
    )),
      (this.priceImpact = r.computePriceImpact(t.midPrice, this.inputAmount, this.outputAmount))
  }
  ;(t.exactIn = function(e, n) {
    return new t(e, n, r.TradeType.EXACT_INPUT)
  }),
    (t.exactOut = function(e, n) {
      return new t(e, n, r.TradeType.EXACT_OUTPUT)
    })
  var e = t.prototype
  return (
    (e.minimumAmountOut = function(t) {
      if ((t.lessThan(c) && o(!1), this.tradeType === r.TradeType.EXACT_OUTPUT)) return this.outputAmount
      var e = new r.Fraction(p)
        .add(t)
        .invert()
        .multiply(this.outputAmount.quotient).quotient
      return r.CurrencyAmount.fromRawAmount(this.outputAmount.currency, e)
    }),
    (e.maximumAmountIn = function(t) {
      if ((t.lessThan(c) && o(!1), this.tradeType === r.TradeType.EXACT_INPUT)) return this.inputAmount
      var e = new r.Fraction(p).add(t).multiply(this.inputAmount.quotient).quotient
      return r.CurrencyAmount.fromRawAmount(this.inputAmount.currency, e)
    }),
    (t.bestTradeExactIn = function(e, n, u, i, s, a, p) {
      var l = void 0 === i ? {} : i,
        f = l.maxNumResults,
        m = void 0 === f ? 3 : f,
        h = l.maxHops,
        d = void 0 === h ? 3 : h
      void 0 === s && (s = []),
        void 0 === a && (a = n),
        void 0 === p && (p = []),
        e.length > 0 || o(!1),
        d > 0 || o(!1),
        n === a || s.length > 0 || o(!1)
      for (var y = a.wrapped, v = u.wrapped, A = 0; A < e.length; A++) {
        var T = e[A]
        if (
          (T.token0.equals(y.currency) || T.token1.equals(y.currency)) &&
          !T.reserve0.equalTo(c) &&
          !T.reserve1.equalTo(c)
        ) {
          var q = void 0
          try {
            q = T.getOutputAmount(y)[0]
          } catch (t) {
            if (t.isInsufficientInputAmountError) continue
            throw t
          }
          if (q.currency.equals(v))
            r.sortedInsert(p, new t(new _([].concat(s, [T]), n.currency, u), n, r.TradeType.EXACT_INPUT), m, R)
          else if (d > 1 && e.length > 1) {
            var k = e.slice(0, A).concat(e.slice(A + 1, e.length))
            t.bestTradeExactIn(k, n, u, { maxNumResults: m, maxHops: d - 1 }, [].concat(s, [T]), q, p)
          }
        }
      }
      return p
    }),
    (e.worstExecutionPrice = function(t) {
      return new r.Price(
        this.inputAmount.currency,
        this.outputAmount.currency,
        this.maximumAmountIn(t).quotient,
        this.minimumAmountOut(t).quotient
      )
    }),
    (t.bestTradeExactOut = function(e, n, u, i, s, a, p) {
      var l = void 0 === i ? {} : i,
        f = l.maxNumResults,
        m = void 0 === f ? 3 : f,
        h = l.maxHops,
        d = void 0 === h ? 3 : h
      void 0 === s && (s = []),
        void 0 === a && (a = u),
        void 0 === p && (p = []),
        e.length > 0 || o(!1),
        d > 0 || o(!1),
        u === a || s.length > 0 || o(!1)
      for (var y = a.wrapped, v = n.wrapped, A = 0; A < e.length; A++) {
        var T = e[A]
        if (
          (T.token0.equals(y.currency) || T.token1.equals(y.currency)) &&
          !T.reserve0.equalTo(c) &&
          !T.reserve1.equalTo(c)
        ) {
          var q = void 0
          try {
            q = T.getInputAmount(y)[0]
          } catch (t) {
            if (t.isInsufficientReservesError) continue
            throw t
          }
          if (q.currency.equals(v))
            r.sortedInsert(p, new t(new _([T].concat(s), n, u.currency), u, r.TradeType.EXACT_OUTPUT), m, R)
          else if (d > 1 && e.length > 1) {
            var k = e.slice(0, A).concat(e.slice(A + 1, e.length))
            t.bestTradeExactOut(k, n, u, { maxNumResults: m, maxHops: d - 1 }, [T].concat(s), q, p)
          }
        }
      }
      return p
    }),
    t
  )
})()
function S(t) {
  return '0x' + t.quotient.toString(16)
}
var j = (function() {
  function t() {}
  return (
    (t.swapCallParameters = function(t, e) {
      var n = t.inputAmount.currency.isNative,
        u = t.outputAmount.currency.isNative
      n && u && o(!1), !('ttl' in e) || e.ttl > 0 || o(!1)
      var i,
        s,
        a,
        c = r.validateAndParseAddress(e.recipient),
        p = S(t.maximumAmountIn(e.allowedSlippage)),
        l = S(t.minimumAmountOut(e.allowedSlippage)),
        f = t.route.path.map(function(t) {
          return t.address
        }),
        m =
          'ttl' in e
            ? '0x' + (Math.floor(new Date().getTime() / 1e3) + e.ttl).toString(16)
            : '0x' + e.deadline.toString(16),
        h = Boolean(e.feeOnTransfer)
      switch (t.tradeType) {
        case r.TradeType.EXACT_INPUT:
          n
            ? ((i = h ? 'swapExactETHForTokensSupportingFeeOnTransferTokens' : 'swapExactETHForTokens'),
              (s = [l, f, c, m]),
              (a = p))
            : u
            ? ((i = h ? 'swapExactTokensForETHSupportingFeeOnTransferTokens' : 'swapExactTokensForETH'),
              (s = [p, l, f, c, m]),
              (a = '0x0'))
            : ((i = h ? 'swapExactTokensForTokensSupportingFeeOnTransferTokens' : 'swapExactTokensForTokens'),
              (s = [p, l, f, c, m]),
              (a = '0x0'))
          break
        case r.TradeType.EXACT_OUTPUT:
          h && o(!1),
            n
              ? ((i = 'swapETHForExactTokens'), (s = [l, f, c, m]), (a = p))
              : u
              ? ((i = 'swapTokensForExactETH'), (s = [l, p, f, c, m]), (a = '0x0'))
              : ((i = 'swapTokensForExactTokens'), (s = [l, p, f, c, m]), (a = '0x0'))
      }
      return { methodName: i, args: s, value: a }
    }),
    t
  )
})()
;(exports.FACTORY_ADDRESS = '0x2EA9051d5a48eA2350b26306f2b959D262cf67e1'),
  (exports.INIT_CODE_HASH = s),
  (exports.InsufficientInputAmountError = O),
  (exports.InsufficientReservesError = I),
  (exports.MINIMUM_LIQUIDITY = a),
  (exports.Pair = P),
  (exports.Route = _),
  (exports.Router = j),
  (exports.Trade = F),
  (exports.computePairAddress = E),
  (exports.inputOutputComparator = C),
  (exports.tradeComparator = R)
//# sourceMappingURL=v2-sdk.cjs.production.min.js.map
